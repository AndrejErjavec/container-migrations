private ArrayList<Migration> generateMigrationPlanMultiStdDev() {
        ArrayList<Migration> migrationPlan = new ArrayList<Migration>();
        float dev = getLoadStdDev();
        float devPrevious = dev;

        ArrayList<Node> availableNodes = new ArrayList<>(nodes);

        // System.out.println("INITIAL STATE");
        // printState();
        // printStdDev();

        while (dev <= devPrevious && availableNodes.size() > 0) {
            Node maxLoadedNode = getMaxLoadedNode(availableNodes);
            Node minLoadedNode = getMinLoadedNode(availableNodes);

            // skip migration if all nodes are equally loaded
            if(minLoadedNode.equals(maxLoadedNode)) break;

            List<Container> migrationCandidates = maxLoadedNode.getContainers();
            migrationCandidates.sort(new Comparator<Container>() {
                @Override
                public int compare(Container ct1, Container ct2) {
                    return ct1.getCpuUsage() - ct2.getCpuUsage();
                }
            });

            // System.out.println(migrationCandidates.stream().map(container -> container.getCpuUsage()).collect(Collectors.toList()));

            int loadDelta = maxLoadedNode.getCpuUsage() - minLoadedNode.getCpuUsage();

            // find the best candidate container to migrate
            Container toMigrate = null;
            for (int i = 0; i < migrationCandidates.size(); i++) {
                Container candidate = migrationCandidates.get(i);
                int nextLoadDelta = Math.abs((maxLoadedNode.getCpuUsage() - candidate.getCpuUsage()) - (minLoadedNode.getCpuUsage() + candidate.getCpuUsage()));
                if (nextLoadDelta > loadDelta) {
                    if (i > 0) toMigrate = migrationCandidates.get(i-1);
                    else toMigrate = migrationCandidates.get(i);
                    break;
                }
                if (i == migrationCandidates.size() - 1) {
                    toMigrate = migrationCandidates.get(i);
                    break;
                }
                loadDelta = nextLoadDelta;
            }

            // perform migration
            simulateMigration(toMigrate, maxLoadedNode, minLoadedNode);
            availableNodes.remove(maxLoadedNode);
            availableNodes.remove(minLoadedNode);

            // calculate standard deviation after migration
            devPrevious = dev;
            dev = getLoadStdDev();
            Migration migration = new Migration(null, null, null);
            // System.out.println("dev: " + dev);
            // System.out.println("dev previous: " + devPrevious);
            if (dev < devPrevious) {
                // System.out.println("Std dev: " + dev);
                takeSnapshot(nodes);
                migration = new Migration(toMigrate.id, maxLoadedNode.id, minLoadedNode.id);
                migrationPlan.add(migration);
                if (outputCSV) { writeMigrationToCsv(migration, toMigrate); }
            }
            // if (outputCSV) { writeMigrationToCsv(migration, toMigrate); }
            // printState();
            // printStdDev();
        }

        if (dev > devPrevious) {
            // System.out.println("Standard deviation before restore: " + getLoadStdDev());
            restorePreviousState();
            // System.out.println("Standard deviation after restore: " + getLoadStdDev());
        }
        if (outputCSV && !(migrationPlan.size() > 0)) { writeMigrationToCsv(null, null); }
        // System.out.println("FINAL STATE");
        // printState();
        return migrationPlan;
    }
